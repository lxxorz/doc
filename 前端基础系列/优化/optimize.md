## 背景
现在需要将系统运行在低成本的服务器上，低成本意味着低性能，和低带宽。就低带宽而言需要对现有的系统网络请求进行优化
优化的手段主要有两个
- 缓存
- 压缩

### 缓存
关于 http 缓存的前置知识可以参考 [[HTTP-Cache]]
主要思路就是，对于已经版本化的文件，代码、图片、html 可以直接加强缓存（类似 `chunk.abc12341234.js` 这样的文件），其他文件则可以加协商缓存，可以看到所有静态资源的请求都是用充分利用了缓存的
强缓存：一直保持不变，除非主动清除缓存, 通过对比每个请求资源在服务器的路径，判断是否进行强缓存
```js
app.use(KoaStatic(join(__dirname, "./"), {extensions: ["html"], setHeaders(resp, path) {
  if(cache_dir.some(dir => path.startsWith(dir))){
    resp.setHeader("Cache-Control", "max-age=31536000, immutable")
  }
}}));
```
协商缓存： 使用 ETag 来做协商缓存，每次对比请求头的 ETag 和服务器端生成的 ETag 是否一直来判断是否使用缓存，服务器的 ETag 使用的是 `koa-etag` 库，是利用文件的更新时间和文件的大小生成的 hash 字符串

![[media/optimize-cache.png]]

### 文本压缩
文本压缩也是一个节省带宽的好方法！
在我们的代码构建过程中先提前准备好压缩文件，通过生成 gzip 的压缩文件
![[optimize-compression.png]]
**每个文件基本上能够节省 70%~80%左右的带宽**

文件压缩率对比 `gzip -l *.gz`
| HTML  | CSS   | Javascript    |
| ----- | ----- | ----- |
| 58.2% | 75.8% | 74.9% |

## 性能测试 
- 桌面环境浏览器
- 1920x1080
- 2M 带宽

### 测试结果
- 无缓存的情况下
![[optimize-no-cache.png]]
- 有缓存的情况
![[optimize-with-cache.png]]


### 网络传输资源大小对比（首页）
| 无缓存无压缩 | 有缓存有压缩 |
| ------ | ------ |
|   27 MB     |    236 kB    |
完全没有缓存的情况下，通过网络传输的资源大概会有 27 MB 左右，当利用了缓存和压缩之后整个系统通过网络传输的资源的大小骤降在 236KB 左右
![[optimize-resource-size.png]]
## 结论
在网络环境较差的情况，通过优化网络请求，增加压缩和缓存，能够极其显著的改善用户的体验，并且节省服务器带宽节省成本。
