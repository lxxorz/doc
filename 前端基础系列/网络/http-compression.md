在 web 方面，有三个压缩方式
- gzip
- deflate
- brotli

## 历史
现在所有的无损压缩算法基本上都可以追溯到两个压缩算法 **LZ77**和**LZ78**
LZ77 算法非常简单，它将文本当中一些重复的地方用三元组 $\langle distance, length\rangle$ 表示
```js
document.addEventListener("click", f);

document.addEventListener("click", g);
```
看上面这段 JavaScript 代码，LZ77 会怎么处理呢，它将 `document.addEventListener("click", ` 这部分用一个元组替代
```
document.addEventListener("click", f);

<13, 32> g);
```
这里的元组代表什么意思呢？这里的 13 代表向前回退 13 字节，32 代表复制 32 个字节

肉眼可见，整段文本被缩小了，但是有一个很明显的问题是，所谓文件内容在计算机当中都是一些字节，当完成压缩之后，怎么保证文件里面的元组是通过压缩算法生成的而非文件本身的内容如此，LZ77 用了一个显得有点呆瓜的方法，那就是将所有的文字内容通过元组形式表示（既然没法区分，那我就消灭你🤡）
所以，假设有以下文本
```
ldd
```
那么就会变成
```
<0,0,a><0,0,b><0,0,c><1,1,E>
```
从以前的一个字节，就会变成四个字节，这里<0, 0, a>代表原来的 a , 通过这样的三元组来代表原来的整个文本文件内容。
这样直接的方式，肯定在某种情况下会出现不仅不会压缩文件，而且文件本身还会变大的滑稽情况
![[http-compression-lz77.png]]
大概五年之后，JACOB ZIV（LZ77 作者）又提出了 LZSS 的压缩算法，相比于 LZ77 算法，LZSS 即使在小文件的情况下也有良好的压缩率